/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { __extends } from 'tslib';
import { MezzuriteUtils, PerformanceTimingService, PerformanceTelemetryService, MezzuriteConstants } from '@microsoft/mezzurite-core';
import { filter } from 'rxjs/operators';
import { Injectable, Directive, ElementRef, Input, NgModule } from '@angular/core';
import { Router, NavigationStart } from '@angular/router';
import 'intersection-observer';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Gets information from package.json
  @type {?} */
var environment = {
    version: require('../package.json').version,
    name: require('../package.json').name
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Extension of Mezzurite Utilities that gets package specific information
 */
var /**
 * Extension of Mezzurite Utilities that gets package specific information
 */
MezzuriteAngularUtils = /** @class */ (function (_super) {
    __extends(MezzuriteAngularUtils, _super);
    function MezzuriteAngularUtils() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    MezzuriteAngularUtils.createMezzuriteObject = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        _super.createMezzuriteObject.call(this, obj);
        (/** @type {?} */ (window)).mezzurite.packageVersion = environment.version;
        (/** @type {?} */ (window)).mezzurite.packageName = environment.name;
    };
    return MezzuriteAngularUtils;
}(MezzuriteUtils));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * RoutingService is responsible for listening to the routing events coming
 * into the application and creating performance marks based on them.
 */
var RoutingService = /** @class */ (function () {
    function RoutingService(router) {
        this.router = router;
        this.endCounter = 0;
        if (!(/** @type {?} */ (window)).mezzurite) {
            (/** @type {?} */ (window)).mezzurite = {};
        }
        MezzuriteAngularUtils.createMezzuriteObject((/** @type {?} */ (window)).mezzurite);
        (/** @type {?} */ (window)).mezzurite.routerPerf = true;
    }
    /**
     * this method begins the listening process. Must be called for code to function properly.
     */
    /**
     * this method begins the listening process. Must be called for code to function properly.
     * @return {?}
     */
    RoutingService.prototype.start = /**
     * this method begins the listening process. Must be called for code to function properly.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var onNavStart$ = (/** @type {?} */ (this)).router.events.pipe(filter(function (event) { return event instanceof NavigationStart; }));
        onNavStart$.subscribe(function (e) {
            _this.handleRoute(e);
        });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    RoutingService.prototype.handleRoute = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        (/** @type {?} */ (window)).mezzurite.routeUrl = e.url;
        if ((/** @type {?} */ (window)).mezzurite.captureCycleStarted) {
            (/** @type {?} */ (window)).mezzurite.captureCycleStarted = false;
            PerformanceTelemetryService.captureTimings(true);
            window.performance.mark(MezzuriteConstants.vltMarkStart);
            // starts a new capture cycle
            PerformanceTelemetryService.startCaptureCycle();
        }
        else {
            // starts the capture cycle to transmit telemetry if current pathname is different than recentPath
            PerformanceTelemetryService.startCaptureCycle();
            // If first load, capture ALT
            if (!(/** @type {?} */ (window)).mezzurite.firstViewLoaded) {
                window.performance.mark(MezzuriteConstants.altMarkEnd);
                window.performance.mark(MezzuriteConstants.vltMarkStart);
                /** @type {?} */
                var fullName = MezzuriteAngularUtils.getName(MezzuriteConstants.altName, MezzuriteAngularUtils.makeId());
                PerformanceTimingService.measure(fullName, 0, MezzuriteConstants.altMarkEnd);
            }
            else {
                window.performance.mark(MezzuriteConstants.vltMarkStart);
            }
        }
    };
    RoutingService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    RoutingService.ctorParameters = function () { return [
        { type: Router }
    ]; };
    return RoutingService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var MezzuriteDirective = /** @class */ (function () {
    function MezzuriteDirective(ref) {
        // tslint:disable-next-line:no-input-rename
        this.title = 'MyComponent';
        this.id = MezzuriteUtils.makeId();
        performance.mark(this.id + MezzuriteConstants.componentMarkStart);
        this.el = ref.nativeElement;
    }
    /**
     * @return {?}
     */
    MezzuriteDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.fullName = MezzuriteUtils.getName(this.title, this.id);
        (/** @type {?} */ (window)).mezzurite.elementLookup[this.fullName] = this.el;
        /** @type {?} */
        var that = this;
        /** @type {?} */
        var config = {
            root: /** @type {?} */ (null),
            // setting it to 'null' sets it to default value: viewport
            rootMargin: '0px'
        };
        /** @type {?} */
        var intObserver = new IntersectionObserver(function (entries, observer) {
            performance.mark(that.id + MezzuriteConstants.componentMarkEnd);
            /** @type {?} */
            var entry = entries[0];
            (/** @type {?} */ (window)).mezzurite.viewportWidth = entry.rootBounds.width;
            (/** @type {?} */ (window)).mezzurite.viewportHeight = entry.rootBounds.height;
            if (entry.isIntersecting) {
                (/** @type {?} */ (window)).mezzurite.vltComponentLookup[that.fullName] = true;
            }
            observer.unobserve(that.el);
        }, config);
        intObserver.observe(this.el);
    };
    MezzuriteDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mezzurite]'
                },] }
    ];
    /** @nocollapse */
    MezzuriteDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    MezzuriteDirective.propDecorators = {
        title: [{ type: Input, args: ['component-title',] }]
    };
    return MezzuriteDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var AngularPerfModule = /** @class */ (function () {
    function AngularPerfModule() {
    }
    /**
     * @return {?}
     */
    AngularPerfModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AngularPerfModule,
            providers: [
                RoutingService
            ]
        };
    };
    AngularPerfModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [MezzuriteDirective],
                    exports: [MezzuriteDirective]
                },] }
    ];
    return AngularPerfModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { RoutingService, AngularPerfModule, MezzuriteDirective as Éµa };
//# sourceMappingURL=mezzurite-angular.js.map
