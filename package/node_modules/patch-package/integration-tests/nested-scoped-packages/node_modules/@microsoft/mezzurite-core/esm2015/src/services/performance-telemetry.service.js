/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { MezzuriteConstants } from '../utils/performance-constants';
import { PerformanceTimingService } from './performance-timing.service';
import { MezzuriteUtils } from './performance-utils.service';
/**
 * Class containing core telemetry functions
 */
export class PerformanceTelemetryService {
    /**
     * Starts capture cycle period
     * @return {?}
     */
    static startCaptureCycle() {
        if (!(/** @type {?} */ (window)).mezzurite.captureCycleStarted) {
            (/** @type {?} */ (window)).mezzurite.startTime = window.performance.now();
            (/** @type {?} */ (window)).mezzurite.captureCycleStarted = true;
            (/** @type {?} */ (window)).mezzurite.captureTimer = setTimeout(function () {
                PerformanceTelemetryService.captureTimings();
            }, MezzuriteConstants.captureCycleTimeout);
        }
    }
    /**
     * Captures timings for the given period
     * @param {?=} isRedirect Bool dictating whether timings were captured at end of cycle or early
     * @return {?}
     */
    static captureTimings(isRedirect = false) {
        clearTimeout((/** @type {?} */ (window)).mezzurite.captureTimer);
        (/** @type {?} */ (window)).mezzurite.endTime = window.performance.now();
        if (!(/** @type {?} */ (window)).mezzurite.captureCycleStarted) {
            (/** @type {?} */ (window)).mezzurite.captureCycleStarted = true;
        }
        PerformanceTelemetryService.submitTelemetry(isRedirect);
        (/** @type {?} */ (window)).mezzurite.captureCycleStarted = false;
    }
    /**
     * Creates timings object to send to telemetry
     * @param {?} isRedirect isRedirect bool
     * @return {?}
     */
    static submitTelemetry(isRedirect) {
        /** @type {?} */
        const timings = [];
        // add redirect value
        timings.push(MezzuriteUtils.createMetric(MezzuriteConstants.redirect, isRedirect === false ? 0 : 1));
        // calculate component measures off slowest resource values
        if ((/** @type {?} */ (window)).mezzurite.elementLookup !== {}) {
            PerformanceTimingService.calculateSlowestResourceBatch();
        }
        /** @type {?} */
        const components = PerformanceTimingService.getCurrentComponents();
        if ((/** @type {?} */ (window)).mezzurite.routerPerf) {
            // alt
            if ((/** @type {?} */ (window)).mezzurite.firstViewLoaded === false) {
                /** @type {?} */
                const altMeasure = (/** @type {?} */ (window)).mezzurite.measures.filter((m) => m.name.indexOf(MezzuriteConstants.altName) > -1)[0];
                timings.push(MezzuriteUtils.createMetric(MezzuriteConstants.altName, altMeasure.clt));
                (/** @type {?} */ (window)).mezzurite.firstViewLoaded = true;
            }
            // vlt
            if (components.length > 0) {
                /** @type {?} */
                const vltResults = PerformanceTimingService.calculateVlt();
                if (vltResults !== null) {
                    timings.push(MezzuriteUtils.createMetric(MezzuriteConstants.vltName, vltResults.vlt, vltResults.components));
                }
            }
            if (components.length === 0) {
                performance.clearMarks(MezzuriteConstants.vltMarkStart);
            }
        }
        if (components.length > 0) {
            timings.push(MezzuriteUtils.createMetric(MezzuriteConstants.allComponents, -1, components));
        }
        this.log(timings);
        MezzuriteUtils.testReset();
    }
    /**
     * Adds remaining metadata to send to logger and dispatches event
     * @param {?} timings
     * @return {?}
     */
    static log(timings) {
        if ((/** @type {?} */ (window)).mezzurite) {
            if (timings.length > 1) {
                /** @type {?} */
                const obj = {
                    Timings: timings,
                    Framework: {
                        name: (/** @type {?} */ (window)).mezzurite.packageName,
                        version: (/** @type {?} */ (window)).mezzurite.packageVersion
                    },
                    ViewportWidth: (/** @type {?} */ (window)).mezzurite.viewportWidth,
                    ViewportHeight: (/** @type {?} */ (window)).mezzurite.viewportHeight,
                    ObjectVersion: MezzuriteConstants.mezzuriteObjectVersion
                };
                // log to console when developing locally
                if ((/** @type {?} */ (window)).location.href.indexOf('localhost') > -1) {
                    console.log('to log for testing: ', obj);
                }
                if ((/** @type {?} */ (window)).mezzurite.EventElement) {
                    (/** @type {?} */ (window)).mezzurite.EventElement.dispatchEvent(new CustomEvent('Timing', { detail: obj }));
                }
            }
            else {
                console.log('nothing for Mezzurite to log.');
            }
        }
    }
    /**
     * Checks whether window.performance is undefined
     * @return {?}
     */
    static compatibilityCheck() {
        /** @type {?} */
        const isCompatible = (window.performance !== undefined);
        if (!isCompatible) {
            /** @type {?} */
            const timings = [
                MezzuriteUtils.createMetric(MezzuriteConstants.unsupportedBrowserName, -1, MezzuriteConstants.unsupportedBrowserPerf)
            ];
            this.log(timings);
        }
        return isCompatible;
    }
}
//# sourceMappingURL=performance-telemetry.service.js.map